extends Nodevar card_pool: Array[CardData] = []var card_colors: Array[Color] = [	Color(0.9, 0.3, 0.3), Color(0.3, 0.5, 0.9), Color(0.3, 0.8, 0.3),	Color(0.9, 0.6, 0.2), Color(0.7, 0.3, 0.9), Color(0.2, 0.8, 0.8),	Color(0.9, 0.9, 0.2), Color(0.9, 0.4, 0.7), Color(0.5, 0.8, 0.2),	Color(0.2, 0.5, 0.8), Color(0.8, 0.3, 0.3), Color(0.3, 0.8, 0.6),	Color(0.8, 0.7, 0.2), Color(0.4, 0.3, 0.8), Color(0.2, 0.7, 0.5),	Color(0.9, 0.2, 0.5), Color(0.6, 0.8, 0.3), Color(0.3, 0.6, 0.9),	Color(0.8, 0.5, 0.2), Color(0.5, 0.2, 0.7),]func _ready() -> void:	_generate_card_pool()func _generate_card_pool() -> void:	card_pool.clear()	# [id, name, cost, atk, hp, dice_array]	var defs := [		# Cost 1		[0, "スライム", 1, 1, 1, [1,2,3,4]],		[1, "ストーンウォール", 1, 1, 4, [3]],		[2, "ゴブリン", 1, 2, 2, [2,5]],		[3, "ナイフィンプ", 1, 3, 1, [1,6]],		# Cost 2		[4, "シールドナイト", 2, 2, 5, [3,4]],		[5, "スカウト", 2, 2, 2, [1,2,3,4,5]],		[6, "ウォリアー", 2, 3, 3, [1,3,5]],		[7, "アサシン", 2, 4, 2, [2,4,6]],		# Cost 3		[8, "フォートレス", 3, 2, 7, [2,4,6]],		[9, "ストライカー", 3, 5, 3, [1,3,4,6]],		[10, "パラディン", 3, 4, 5, [1,3,5]],		[11, "バーサーカー", 3, 6, 2, [1,2,5,6]],		# Cost 4		[12, "アイアンゴーレム", 4, 3, 9, [1,4,5]],		[13, "ブレードマスター", 4, 5, 5, [1,2,3,4,5]],		[14, "ドラゴンナイト", 4, 7, 4, [2,3,5,6]],		[15, "ウォーロード", 4, 5, 7, [1,3,6]],		# Cost 5		[16, "タイタン", 5, 4, 8, [1,2,3,4,5,6]],		[17, "ドラゴン", 5, 7, 8, [2,4,6]],		[18, "デスブリンガー", 5, 9, 4, [1,2,3,5,6]],		[19, "エンシェント", 5, 6, 6, [1,2,3,4,5,6]],	]	for d in defs:		var card := CardData.new()		card.id = d[0]		card.card_name = d[1]		card.mana_cost = d[2]		card.atk = d[3]		card.hp = d[4]		var dice: Array[int] = []		for v in d[5]:			dice.append(v)		card.attack_dice = dice		card.color = card_colors[d[0] % card_colors.size()]		card.icon_name = ["sword", "shield", "star", "flame", "bolt", "heart", "skull", "crown", "gem", "arrow"][d[0] % 10]		card_pool.append(card)func get_card_by_id(id: int) -> CardData:	for card in card_pool:		if card.id == id:			return card	return nullfunc get_all_cards() -> Array[CardData]:	return card_poolfunc build_random_deck() -> Array[CardData]:	var deck: Array[CardData] = []	var pool_copy := card_pool.duplicate()	pool_copy.shuffle()	var count_map := {}	for card in pool_copy:		var current_count: int = count_map.get(card.id, 0)		if current_count < 2 and deck.size() < 20:			deck.append(card.duplicate_card())			count_map[card.id] = current_count + 1	# Fill remaining with duplicates	pool_copy.shuffle()	while deck.size() < 20:		var pick: CardData = pool_copy[randi() % pool_copy.size()]		var current_count: int = count_map.get(pick.id, 0)		if current_count < 2:			deck.append(pick.duplicate_card())			count_map[pick.id] = current_count + 1	deck.shuffle()	return deck